# 2025-06-22 Symbolic Execution–Driven Validation of C-to-Rust Program Translation Report

## Simple pipeline

This is a simple pipeline for validating C-to-Rust translation, designed to clarify the concepts and demonstrate how the `klee` tool can be used effectively.

```
    A[C Function with string logic] --> B[KLEE symbolic execution]
    B --> C[Test cases + inputs]
    C --> D[Run C version with inputs]
    C --> E[Run Rust version with same inputs]
    D --> F[Output from C]
    E --> G[Output from Rust]
    F --> H[Compare outputs (differential testing)]
    G --> H
    C --> I[Auto-generate Rust test functions]
```

## Goal
1. Apply KLEE symbolic execution to complex C functions (e.g., string manipulation).

2. Extract test inputs generated by KLEE automatically.

3. Run both the original C function and the Rust equivalent on these inputs and compare outputs (differential testing).

4. Automatically generate Rust unit tests from these test cases.

## Steps

### Step 1: Sample C Function with String Logic (strcmp example)
```c
#include <string.h>
#include <stdio.h>
#include <klee/klee.h>

// A simple wrapper around strcmp
int my_strcmp(const char* a, const char* b) {
    return strcmp(a, b);
}

int main() {
    char a[5], b[5];
    klee_make_symbolic(a, sizeof(a), "a");
    klee_make_symbolic(b, sizeof(b), "b");
    a[4] = '\0';
    b[4] = '\0';

    int result = my_strcmp(a, b);
    printf("%d\n", result);
    return 0;
}
```

### Step 2: Compile C to LLVM bitcode and run KLEE
```bash
clang -I /path/to/klee/include -emit-llvm -c -g strcmp_sample.c -o strcmp_sample.bc

klee strcmp_sample.bc
```
-> `KLEE` will generate multiple test cases (`.ktest` files) under `klee-last/` folder.

-> Each `.ktest` contains concrete inputs for `a` and `b`.


### Step 3: Extract Inputs from .ktest Files (optional)
Using a Python script to parse the `.ktest` files:

```bash
python3 parse_klee_test.py
```


### Step 4: Run the C and Rust executables on these inputs and compare outputs
We need two small executables:

- `c_runner.c` — accepts inputs a and b as command line args, runs the C function and outputs result.

- `rust_runner.rs` — same interface but runs Rust version of the function.

Example Python code to run and compare:

```bash
python3 run_compare.py
```

### Step 5: Automatically generate Rust unit test code from the test cases
Given inputs and expected results (from the C runner), generate Rust test functions:

```python
def gen_rust_test_case(a, b, expected, idx):
    return f'''
#[test]
fn test_case_{idx}() {{
    let a = "{a}";
    let b = "{b}";
    assert_eq!(test_strcmp(a, b), {expected});
}}
'''

def generate_rust_tests(test_cases):
    tests = "use my_crate::test_strcmp;\n"
    for i, (a, b) in enumerate(test_cases):
        expected = run_exec("./c_runner", a, b)
        tests += gen_rust_test_case(a, b, expected, i)
    return tests
# Write to file
with open("tests/auto_tests.rs", "w") as f:
    f.write(generate_rust_tests(test_cases))
```

## Summary
1. Use `KLEE` to generate symbolic test inputs for complex C functions.

2. Extract these inputs automatically from .ktest files.

3. Run both C and Rust implementations on these inputs to verify output consistency.

4. Auto-generate Rust unit tests to continuously check correctness with real test cases.