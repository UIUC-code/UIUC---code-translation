# Report: Handling struct Student Inputs in KLEE

## 1. Background and Question

KLEE typically requires clearly defined input parameters for each test target function. In real projects, this implies writing a driver (`main`) that marshals all necessary inputs—especially for functions accepting complex types such as structs. The question posed was whether writing such a `main` routine, with fully symbolic struct fields read from input, is practical, and what implications this has for test-generation effort.

## 2. Approach

To answer the question, I coded 2 programs listed below:
`src/Alexander/main.c`
`src/Alexander/student.c`

To generate test cases for these programs, I: 

- First defined a `struct Student` with fields: a fixed‐length `name` array, an `int age`, and a `float grades[5]`.
- Then used `klee_make_symbolic(&s, sizeof(s), "struct_student")` to mark the entire struct as symbolic in one call, rather than making each field symbolic separately. Then, I explicitly null-terminated `s.name[49]` to avoid unbounded string issues.
- Introduced a global `volatile int path_tracker` to record side effects from within `processStudent`, improving branch coverage tracking across calls.

The `processStudent` function (in `student.c`) performed two checks:  
  1. Age validity (`s.age < 0` or `> 120`)  
  2. Per-grade validity (`s.grades[i] < 0`)  
Each invalid condition sets a flag in `path_tracker` and in corresponding global invalidity markers.

## 3. Results

- KLEE ran to completion on this driver, generating a suite of test cases that exercise combinations of valid/invalid age and grade values.
- Measured branch coverage (BCov) reached **79.75%**, demonstrating that symbolicizing an entire struct at once is sufficient to drive multi-field exploration without writing separate `klee_make_symbolic` calls for each member.

## 4. Discussion

- **Feasibility**: Instrumenting a `main` that casts a struct to a symbolic blob works reliably. It greatly reduces boilerplate when structs have many fields.
- **Coverage**: While 79.75% coverage is substantial, remaining gaps correspond to boundary conditions around float sums and certain combinations of grade flags. These could be addressed by adding explicit constraints or additional path-tracking.
- **Maintainability**: Encapsulating struct construction in a single `klee_make_symbolic` improves maintainability. Future struct extensions simply increase `sizeof`, with no additional code needed in `main`.

## 5. Conclusion

Writing a `main` to fully symbolize complex structs is not only practical but also greatly reduces repetitive code. It directly answers the concern: with a single `klee_make_symbolic` call, I can generate thorough test suites for functions that take rich data types.
